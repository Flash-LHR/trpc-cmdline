// Code generated by trpc-go/trpc-cmdline {{ .TRPCCmdlineVersion }}. DO NOT EDIT.
// source: {{.Protofile}}

{{ $domainName := .Domain }}
{{ $groupName := .GroupName }}
{{ $versionSuffix := .VersionSuffix }}
{{- $serviceSuffix := "" -}}
{{- if not .NoServiceSuffix }}
    {{- $serviceSuffix = "Service" }}
{{- end }}

{{ $pkgName := .PackageName -}}
{{ $goPkgName := .PackageName|gopkg -}}
{{ $appName := .AppName -}}
{{ $serverName := .ServerName -}}
{{ $protocol := .Protocol -}}
{{ $protofile := .Protofile -}}
{{- $goPkgOption := "" -}}
{{- with .FileOptions.go_package -}}
  {{- $goPkgOption = . -}}
  {{- $goPkgName = (splitList "/" $goPkgOption)|last|gopkg -}}
{{- end -}}
{{- $importStream := false }}
{{- $existRESTfulHTTPRule := false }}
{{- range $service := .Services }}
    {{- range $rpc := $service.RPC }}
        {{- if ne (len .RESTfulAPIInfo.ContentList) 0 }}
            {{- $existRESTfulHTTPRule = true}}
        {{- end }}
        {{- if or $rpc.ClientStreaming $rpc.ServerStreaming }}
            {{- $importStream = true }}
        {{- end }}
    {{- end }}
{{- end }}
package {{ splitList ";" $goPkgName | last }}

{{ $goPkgName = trimright ";" $goPkgName }}

import (
	"context"
	"fmt"

   	_ "{{ $domainName }}/{{ $groupName }}/trpc-go{{ $versionSuffix }}"
   	_ "{{ $domainName }}/{{ $groupName }}/trpc-go{{ $versionSuffix }}/http"
   	{{- if and (ne .Protocol "trpc") (ne .Protocol "http") (ne .Protocol "grpc") }}
    _ "{{ $domainName }}/{{ $groupName }}/trpc-codec/{{.Protocol}}{{ $versionSuffix }}"
   	{{- end }}
   	{{- if  (eq .Protocol "grpc") }}
     "{{ $domainName }}/{{ $groupName }}/trpc-codec/{{.Protocol}}{{ $versionSuffix }}"
	{{- end }}
    {{- if $existRESTfulHTTPRule }}
    "{{ $domainName }}/{{ $groupName }}/trpc-go{{ $versionSuffix }}/restful"
	{{- end }}
    "{{ $domainName }}/{{ $groupName }}/trpc-go{{ $versionSuffix }}/server"
    "{{ $domainName }}/{{ $groupName }}/trpc-go{{ $versionSuffix }}/client"
    "{{ $domainName }}/{{ $groupName }}/trpc-go{{ $versionSuffix }}/codec"
    {{- if $importStream }}
    "{{ $domainName }}/{{ $groupName }}/trpc-go{{ $versionSuffix }}/stream"
    {{- end }}
    {{- if eq $protocol "grpc" }}
    "{{ $domainName }}/{{ $groupName }}/trpc-go{{ $versionSuffix }}/filter"
    {{- end }}
    {{- range .ImportsX }}
    	{{- if ne $goPkgName .Path }}
    		{{.Name}} "{{.Path}}"
    	{{- end }}
    {{- end }}
)

// START ======================================= Server Service Definition ======================================= START

{{ range $service := .Services }}
{{- $svrName := $service.Name -}}
{{- $svrNameCamelCase := $service.Name|camelcase -}}

{{- $serviceStream := false }}
{{- range $rpc := $service.RPC }}
{{- if or $rpc.ClientStreaming $rpc.ServerStreaming }}
{{- $serviceStream = true }}
{{- end }}
{{- end }}

// {{$svrNameCamelCase}}{{$serviceSuffix}} defines service.
type {{$svrNameCamelCase}}{{$serviceSuffix}} interface {
	{{- range $rpc := $service.RPC -}}
	{{- $rpcName := .Name | camelcase -}}
	{{- $rpcReqType := (simplify (gofulltypex .RequestType $.FileDescriptor) $goPkgName)|export }}
   	{{- $rpcRspType := (simplify (gofulltypex .ResponseType $.FileDescriptor) $goPkgName)|export }}
	{{ with .LeadingComments }}// {{$rpcName}} {{.}}{{ end }}
    {{- if $rpc.ClientStreaming }}
    {{$rpcName}}({{$svrNameCamelCase}}_{{$rpcName}}Server) error {{ with .TrailingComments}}// {{.}}{{ end }}
    {{- else }}
    {{- if $rpc.ServerStreaming }}
    {{$rpcName}}(*{{$rpcReqType}}, {{$svrNameCamelCase}}_{{$rpcName}}Server) error {{ with .TrailingComments}}// {{.}}{{ end }}
    {{- else }}
    {{$rpcName}}(ctx context.Context, req *{{$rpcReqType}}) (*{{$rpcRspType}}, error) {{ with .TrailingComments}}// {{.}}{{ end }}
    {{- end }}
    {{- end }}
    {{- end }}
}

{{range $service.RPC -}}
{{- $rpcName := .Name | camelcase -}}
{{- $rpcReqType := (simplify (gofulltypex .RequestType $.FileDescriptor) $goPkgName)|export }}
{{- $rpcRspType := (simplify (gofulltypex .ResponseType $.FileDescriptor) $goPkgName)|export }}

{{- if and (ne .ClientStreaming true) (ne .ServerStreaming true) }}
func {{$svrNameCamelCase}}{{$serviceSuffix}}_{{$rpcName}}_Handler(svr interface{}, ctx context.Context, f server.FilterFunc) (interface{}, error) {
    req := &{{$rpcReqType}}{}
	filters, err := f(req)
    if err != nil {
    	return nil, err
    }
    handleFunc := func(ctx context.Context, reqbody interface{}) (interface{}, error) {
		return svr.({{$svrNameCamelCase}}{{$serviceSuffix}}).{{$rpcName}}(ctx, reqbody.(*{{$rpcReqType}}))
	}
    {{ if eq $protocol "grpc" }}
    // get req from ctx
    grpcData := ctx.Value(grpc.ContextKeyHeader).(*grpc.Header)
    req = grpcData.Req.(*{{$rpcReqType}})
    {{ end }}
    var rsp interface{}
    rsp, err = filters.Filter(ctx, req, handleFunc)
	if err != nil {
		return nil, err
	}
    {{- if eq $protocol "grpc" }}
    // Set rsp to ctx, and set rsp empty.
    grpcData.Rsp = rsp
    rsp = &{{$rpcRspType}}{}
    {{- end }}
	return rsp, nil
}
{{- else }}
func {{$svrNameCamelCase}}{{$serviceSuffix}}_{{$rpcName}}_Handler(srv interface{}, stream server.Stream) error {
    {{- if (ne .ClientStreaming true) }}
    m := new({{$rpcReqType}})
    if err := stream.RecvMsg(m); err != nil { return err }
    return srv.({{$svrNameCamelCase}}{{$serviceSuffix}}).{{$rpcName}}(m, &{{$svrNameCamelCase|untitle}}{{$rpcName}}Server{stream})
    {{- else }}
    return srv.({{$svrNameCamelCase}}{{$serviceSuffix}}).{{$rpcName}}(&{{$svrNameCamelCase|untitle}}{{$rpcName}}Server{stream})
    {{- end }}
}
{{ $genSend := .ServerStreaming }}
{{- $genSendAndClose := not .ServerStreaming -}}
{{- $genRecv := .ClientStreaming -}}
type {{$svrNameCamelCase}}_{{$rpcName}}Server interface {
    {{- if $genSend }}
    Send(*{{$rpcRspType}}) error
    {{- end }}
    {{- if $genSendAndClose }}
    SendAndClose(*{{$rpcRspType}}) error
    {{- end }}
    {{- if $genRecv }}
    Recv() (*{{$rpcReqType}}, error)
    {{- end }}
    server.Stream
}

type {{$svrNameCamelCase|untitle}}{{$rpcName}}Server struct {
    server.Stream
}

{{ if $genSend }}
func (x *{{$svrNameCamelCase|untitle}}{{$rpcName}}Server) Send(m *{{$rpcRspType}}) error {
    return x.Stream.SendMsg(m)
}
{{ end }}

{{ if $genSendAndClose }}
func (x *{{$svrNameCamelCase|untitle}}{{$rpcName}}Server) SendAndClose(m *{{$rpcRspType}}) error {
    return x.Stream.SendMsg(m)
}
{{ end }}

{{ if $genRecv }}
func (x *{{$svrNameCamelCase|untitle}}{{$rpcName}}Server) Recv() (*{{$rpcReqType}}, error) {
    m := new({{$rpcReqType}})
    if err := x.Stream.RecvMsg(m); err != nil { return nil, err }
    return m, nil
}
{{ end }}
{{- end }}
{{end -}}

{{- range $service.RPC -}}
{{- $rpcName := .Name | camelcase }}
{{- if and (ne .ClientStreaming true ) (ne .ServerStreaming true ) }}

{{- $rpcReqType := (simplify (gofulltypex .RequestType $.FileDescriptor) $goPkgName)|export }}
{{- $rpcRspType := (simplify (gofulltypex .ResponseType $.FileDescriptor) $goPkgName)|export }}

{{- range $index, $content := .RESTfulAPIInfo.ContentList -}}
{{- if $content.RequestBody}}
// requestBody{{$svrNameCamelCase}}{{$serviceSuffix}}{{$rpcName}}RESTfulPath{{$index}} {{$content.Method}}: {{$content.PathTmpl}}
type requestBody{{$svrNameCamelCase}}{{$serviceSuffix}}{{$rpcName}}RESTfulPath{{$index}} struct{}

func (requestBody{{$svrNameCamelCase}}{{$serviceSuffix}}{{$rpcName}}RESTfulPath{{$index}}) Locate(message restful.ProtoMessage) interface{} {
	x := message.(*{{$rpcReqType}})
	{{- if eq $content.RequestBody "*"}}
	return x
	{{- else}}
	return &x.{{camelcase $content.RequestBody}}
	{{- end}}
}

func (requestBody{{$svrNameCamelCase}}{{$serviceSuffix}}{{$rpcName}}RESTfulPath{{$index}}) Body() string {
	return "{{$content.RequestBody}}"
}
{{- end -}}

{{- if $content.ResponseBody}}
// responseBody{{$svrNameCamelCase}}{{$serviceSuffix}}{{$rpcName}}RESTfulPath{{$index}} {{$content.Method}}: {{$content.PathTmpl}}
type responseBody{{$svrNameCamelCase}}{{$serviceSuffix}}{{$rpcName}}RESTfulPath{{$index}} struct{}

func (responseBody{{$svrNameCamelCase}}{{$serviceSuffix}}{{$rpcName}}RESTfulPath{{$index}}) Locate(message restful.ProtoMessage) interface{} {
	x := message.(*{{$rpcRspType}})
	{{- if eq $content.ResponseBody "*"}}
	return x
	{{- else}}
	return &x.{{camelcase $content.ResponseBody}}
	{{- end}}
}

func (responseBody{{$svrNameCamelCase}}{{$serviceSuffix}}{{$rpcName}}RESTfulPath{{$index}}) ResponseBody() string {
	return "{{$content.ResponseBody}}"
}

{{end}}
{{end}}
{{end}}
{{end}}

// {{$svrNameCamelCase}}Server_ServiceDesc descriptor for server.RegisterService.
var {{$svrNameCamelCase}}Server_ServiceDesc = server.ServiceDesc {
    ServiceName: "
    {{- if and $appName $serverName -}}
        trpc.{{$appName}}.{{$serverName}}.{{$service.Name -}}
    {{- else -}}
        {{- $pkgName}}.{{$service.Name -}}
    {{- end}}",
    HandlerType: ((*{{$svrNameCamelCase}}{{$serviceSuffix}})(nil)),
    {{- if $serviceStream }}
        StreamHandle: stream.NewStreamDispatcher(),
    {{- end }}
    Methods: []server.Method{
        {{- range (mergerpc $service.RPC $service.RPCx) }}
        {{- if and (ne .ClientStreaming true ) (ne .ServerStreaming true ) }}
            {{- $rpcName := .Name | camelcase }}
            {
                Name: "{{.FullyQualifiedCmd}}",
                Func: {{$svrNameCamelCase}}{{$serviceSuffix}}_{{$rpcName}}_Handler,
                {{if .RESTfulAPIInfo.ContentList }}
					{{- $rpcReqType := (simplify (gofulltypex .RequestType $.FileDescriptor) $goPkgName)|export }}
					{{- $rpcRspType := (simplify (gofulltypex .ResponseType $.FileDescriptor) $goPkgName)|export }}

                    {{- $fullyQualifiedCmd := .FullyQualifiedCmd -}}
                    Bindings: []*restful.Binding{
                        {{- range $index, $content := .RESTfulAPIInfo.ContentList -}}
                        {
                            Name:   "{{$fullyQualifiedCmd}}",
                            Input:  func() restful.ProtoMessage { return new({{$rpcReqType}}) },
                            Filter: func(svc interface{}, ctx context.Context, reqbody interface{}) (interface{}, error) {
                                return svc.({{$svrNameCamelCase}}{{$serviceSuffix}}).{{$rpcName}}(ctx, reqbody.(*{{$rpcReqType}}))
                            },
                            HTTPMethod: "{{$content.Method}}",
                            Pattern: restful.Enforce("{{$content.PathTmpl}}"),
                            Body: {{ if $content.RequestBody -}}
                                      requestBody{{$svrNameCamelCase}}{{$serviceSuffix}}{{$rpcName}}RESTfulPath{{$index}}{}
                                  {{- else -}}
                                      nil
                                  {{- end}},
                            ResponseBody: {{ if $content.ResponseBody -}}
                                              responseBody{{$svrNameCamelCase}}{{$serviceSuffix}}{{$rpcName}}RESTfulPath{{$index}}{}
                                          {{- else}}
                                              nil
                                          {{- end}},
                        },
                        {{- end -}}
                    },
                {{ end }}
            },
            {{- end }}
        {{- end}}
    },
    {{- if $serviceStream }}
    Streams: []server.StreamDesc{
        {{- range $service.RPC}}
        {{- if or .ClientStreaming .ServerStreaming }}
        {{- $rpcName := .Name | camelcase }}
            {
	       {{- if eq $protocol "trpc" }}
               StreamName: "{{.FullyQualifiedCmd}}",
	       {{- end }}
	       {{- if eq $protocol "grpc" }}
               StreamName: "{{$rpcName}}",
	       {{- end }}
                Handler: {{$svrNameCamelCase}}{{$serviceSuffix}}_{{$rpcName}}_Handler,
                ServerStreams: {{ .ServerStreaming }},
            },
        {{- end }}
        {{- end }}
    },
    {{- end }}
}

// Register{{$svrNameCamelCase}}{{$serviceSuffix}} registers service.
func Register{{$svrNameCamelCase}}{{$serviceSuffix}}(s server.Service, svr {{$svrNameCamelCase}}{{$serviceSuffix}}) {
    if err := s.Register(&{{$svrNameCamelCase}}Server_ServiceDesc, svr); err != nil {
        panic(fmt.Sprintf("{{$svrNameCamelCase}} register error:%v", err))
    }
    {{- if eq $protocol "grpc" }}
    // register service to grpc
    if err := grpc.Register({{$svrNameCamelCase}}Server_ServiceDesc.ServiceName,
    "{{$protofile}}",
    []grpc.RegisterMethodsInfo{
        {{- range $service.RPC}}
		{{- $rpcReqType := (simplify (gofulltypex .RequestType $.FileDescriptor) $goPkgName)|export }}
		{{- $rpcRspType := (simplify (gofulltypex .ResponseType $.FileDescriptor) $goPkgName)|export }}

        {{- if and (ne .ClientStreaming true ) (ne .ServerStreaming true ) }}
        {{- $rpcName := .Name | camelcase }}
            {
                Method: server.Method{
                    Name: "{{$rpcName}}",
                    Func: {{$svrNameCamelCase}}{{$serviceSuffix}}_{{$rpcName}}_Handler,
                },
                ReqType: reflect.TypeOf({{$rpcReqType}}{}),
                RspType: reflect.TypeOf({{$rpcRspType}}{}),
            },
        {{- end }}
        {{- end }}
    }); err != nil {
        panic(fmt.Sprintf("grpc register {{$svrNameCamelCase}} error:%v", err))
    }
    if err := grpc.RegisterStream({{$svrNameCamelCase}}Server_ServiceDesc.ServiceName,
    "{{$protofile}}",
    {{$svrNameCamelCase}}Server_ServiceDesc.Streams,
    svr, (*{{$svrNameCamelCase}}{{$serviceSuffix}})(nil)); err != nil {
        panic(fmt.Sprintf("grpc register {{$svrNameCamelCase}} streams error:%v",   err))
    }
    {{- end }}
}

{{ end }}

// START --------------------------------- Default Unimplemented Server Service --------------------------------- START

{{ range $service := .Services }}
{{- $svrName := $service.Name | camelcase | untitle -}}
{{- $svrNameCamelCase := $service.Name|camelcase -}}
{{- $unimplementedName := (printf "Unimplemented%s" ($svrNameCamelCase)) -}}

type {{$unimplementedName}} struct {}

{{ range $index, $method := $service.RPC }}

{{- $rpcName := $method.Name | camelcase -}}
{{- $rpcReqType := (simplify (gofulltypex $method.RequestType $.FileDescriptor) $goPkgName)|export }}
{{- $rpcRspType := (simplify (gofulltypex $method.ResponseType $.FileDescriptor) $goPkgName)|export }}

{{- $reqTypePkg := $method.RequestTypePkgDirective -}}
{{- with $method.RequestTypeFileOptions.go_package -}}
  {{- $reqTypePkg = . -}}
{{- end -}}

{{ with .LeadingComments }}
// {{$rpcName}} {{.}}
{{- end }}
{{- if and $method.ClientStreaming $method.ServerStreaming }}
func (s *{{$unimplementedName}}) {{$rpcName}}(stream {{$svrNameCamelCase}}_{{$rpcName}}Server) error {
    return errors.New("rpc {{$rpcName}} of service {{$svrNameCamelCase}} is not implemented")
}
{{- else }}
{{- if $method.ClientStreaming }}
func (s *{{$unimplementedName}}) {{$rpcName}}(stream {{$svrNameCamelCase}}_{{$rpcName}}Server) error {
    return errors.New("rpc {{$rpcName}} of service {{$svrNameCamelCase}} is not implemented")
}
{{- else }}
{{- if $method.ServerStreaming }}
func (s *{{$unimplementedName}}) {{$rpcName}}(req *{{$rpcReqType}}, stream {{$svrNameCamelCase}}_{{$rpcName}}Server) error {
    return errors.New("rpc {{$rpcName}} of service {{$svrNameCamelCase}} is not implemented")
}
{{- else }}
func (s *{{$unimplementedName}}) {{$rpcName}}(ctx context.Context, req *{{$rpcReqType}}) (*{{$rpcRspType}}, error) {
    return nil, errors.New("rpc {{$rpcName}} of service {{$svrNameCamelCase}} is not implemented")
}
{{- end }}
{{- end }}
{{- end }}

{{- end }}
{{end}}

// END --------------------------------- Default Unimplemented Server Service --------------------------------- END

// END ======================================= Server Service Definition ======================================= END

// START ======================================= Client Service Definition ======================================= START

{{ range $service := .Services }}
{{ $svrNameCamelCase := $service.Name | camelcase }}

// {{$svrNameCamelCase}}ClientProxy defines service client proxy
type {{$svrNameCamelCase}}ClientProxy interface {
    {{- range $rpc := $service.RPC -}}
    {{- $rpcName := .Name | camelcase -}}
	{{- $rpcReqType := (simplify (gofulltypex .RequestType $.FileDescriptor) $goPkgName)|export }}
	{{- $rpcRspType := (simplify (gofulltypex .ResponseType $.FileDescriptor) $goPkgName)|export }}
   	{{ with .LeadingComments }}// {{$rpcName}} {{.}}{{- end }}
    {{- if and (ne .ClientStreaming true) (ne .ServerStreaming true) }}
    {{$rpcName}}(ctx context.Context, req *{{$rpcReqType}}, opts ...client.Option) (rsp *{{$rpcRspType}}, err error) {{ with .TrailingComments }}// {{.}}{{ end }}
    {{- else }}
    {{- if .ClientStreaming }}
    {{$rpcName}}(ctx context.Context, opts ...client.Option) ({{$svrNameCamelCase}}_{{$rpcName}}Client, error) {{ with .TrailingComments }}// {{.}}{{ end }}
    {{- else }}
    {{$rpcName}}(ctx context.Context, req *{{$rpcReqType}}, opts ...client.Option) ({{$svrNameCamelCase}}_{{$rpcName}}Client, error) {{ with .TrailingComments }}// {{.}}{{ end }}
    {{- end }}
    {{- end }}
    {{- end }}
}

type {{$svrNameCamelCase}}ClientProxyImpl struct{
    client client.Client
    {{- if $importStream }}
    streamClient stream.Client
    {{- end }}
    opts []client.Option
}

var New{{$svrNameCamelCase}}ClientProxy = func(opts...client.Option) {{$svrNameCamelCase}}ClientProxy {
{{- if $importStream }}
    {{- if ne $protocol "grpc" }}
    return &{{$svrNameCamelCase}}ClientProxyImpl {client: client.DefaultClient, streamClient: stream.DefaultStreamClient, opts: opts}
	{{- else }}
    return &{{$svrNameCamelCase}}ClientProxyImpl {client: client.DefaultClient, streamClient: grpc.DefaultStreamClient, opts: opts}
    {{- end }}
{{- else }}
    return &{{$svrNameCamelCase}}ClientProxyImpl {client: client.DefaultClient, opts: opts}
{{- end }}
}

{{range $rpc := $service.RPC}}
{{- $rpcName := .Name | camelcase -}}
{{- $rpcReqType := (simplify (gofulltypex .RequestType $.FileDescriptor) $goPkgName)|export }}
{{- $rpcRspType := (simplify (gofulltypex .ResponseType $.FileDescriptor) $goPkgName)|export }}

{{ if and (ne .ClientStreaming true) (ne .ServerStreaming true) }}
func (c *{{$svrNameCamelCase}}ClientProxyImpl) {{$rpcName}}(ctx context.Context, req *{{$rpcReqType}}, opts ...client.Option) (*{{$rpcRspType}}, error) {
    {{- if eq $protocol "grpc" }}
    // set req to ctx
	h := ctx.Value(grpc.ContextKeyHeader)
	var header *grpc.Header
	if h == nil {
		header = &grpc.Header{}
		ctx = context.WithValue(ctx, grpc.ContextKeyHeader, header)
	} else {
		var ok bool
		header, ok = h.(*grpc.Header)
		if !ok {
			return nil, errors.New(fmt.Sprintf("grpc header in context cannot be transferred to grpc.Header"))
		}
	}
	header.Req = req
	header.Rsp = &{{$rpcRspType}}{}
    {{- end }}
	ctx, msg := codec.WithCloneMessage(ctx)
    defer codec.PutBackMessage(msg)
	msg.WithClientRPCName("{{.FullyQualifiedCmd}}")
	msg.WithCalleeServiceName({{$svrNameCamelCase}}Server_ServiceDesc.ServiceName)
	msg.WithCalleeApp("{{$appName}}")
	msg.WithCalleeServer("{{$serverName}}")
	msg.WithCalleeService("{{$service.Name}}")
	msg.WithCalleeMethod("{{$rpcName}}")
	msg.WithSerializationType(codec.SerializationTypePB)
	callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)
	rsp := &{{$rpcRspType}}{}
    {{- if eq $protocol "grpc" }}
    callopts = append(callopts, client.WithProtocol("grpc"))
	callopts = append(callopts, client.WithFilter(func(ctx context.Context, req1, rsp1 interface{}, next filter.ClientHandleFunc) error {
		err := next(ctx, req1, rsp1)
		header := ctx.Value(grpc.ContextKeyHeader).(*grpc.Header)
		*rsp = *header.Rsp.(*{{$rpcRspType}})
		return err
	}))
    {{- end }}
	if err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {
	    return nil, err
	}
	return rsp, nil
}
{{ else }}
{{- if .ClientStreaming }}
func (c *{{$svrNameCamelCase}}ClientProxyImpl) {{$rpcName}}(ctx context.Context, opts ...client.Option) ({{$svrNameCamelCase}}_{{$rpcName}}Client, error) {
{{- else }}
func (c *{{$svrNameCamelCase}}ClientProxyImpl) {{$rpcName}}(ctx context.Context, req *{{$rpcReqType}}, opts ...client.Option) ({{$svrNameCamelCase}}_{{$rpcName}}Client, error) {
{{- end }}
    ctx, msg := codec.WithCloneMessage(ctx)

	msg.WithClientRPCName("{{.FullyQualifiedCmd}}")
	msg.WithCalleeServiceName({{$svrNameCamelCase}}Server_ServiceDesc.ServiceName)
	msg.WithCalleeApp("{{$appName}}")
	msg.WithCalleeServer("{{$serverName}}")
	msg.WithCalleeService("{{$service.Name}}")
	msg.WithCalleeMethod("{{$rpcName}}")
	msg.WithSerializationType(codec.SerializationTypePB)

	clientStreamDesc := &client.ClientStreamDesc{}
	{{- if eq $protocol "trpc" }}
	clientStreamDesc.StreamName = "{{.FullyQualifiedCmd}}"
	{{- end }}
	{{- if eq $protocol "grpc" }}
	clientStreamDesc.StreamName = "{{$rpcName}}"
	{{- end  }}
	clientStreamDesc.ClientStreams = {{.ClientStreaming}}
    clientStreamDesc.ServerStreams = {{.ServerStreaming}}

    callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)

	stream, err := c.streamClient.NewStream(ctx, clientStreamDesc, "{{.FullyQualifiedCmd}}", callopts...)
    if err != nil {
		return nil, err
	}
	x := &{{$svrNameCamelCase|untitle}}{{$rpcName}}Client{stream}
	{{- if and (ne .ClientStreaming true) .ServerStreaming }}
	if err := x.ClientStream.SendMsg(req); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	{{- end }}
	return x, nil
}
{{ $genSend := .ClientStreaming }}
{{ $genRecv := .ServerStreaming }}
{{ $genCloseAndRecv := not .ServerStreaming }}
type {{$svrNameCamelCase}}_{{$rpcName}}Client interface {
	{{- if $genSend }}
	Send(*{{$rpcReqType}}) error
	{{- end }}
	{{- if $genRecv }}
	Recv() (*{{$rpcRspType}}, error)
	{{- end }}
	{{- if $genCloseAndRecv }}
	CloseAndRecv() (*{{$rpcRspType}}, error)
	{{- end }}
	client.ClientStream
}

type {{$svrNameCamelCase|untitle}}{{$rpcName}}Client struct {
	client.ClientStream
}
{{ if $genSend }}
func (x *{{$svrNameCamelCase|untitle}}{{$rpcName}}Client) Send(m *{{$rpcReqType}}) error {
	return x.ClientStream.SendMsg(m)
}
{{ end }}
{{ if $genRecv}}
func (x *{{$svrNameCamelCase|untitle}}{{$rpcName}}Client) Recv() (*{{$rpcRspType}}, error) {
	m := new({{$rpcRspType}})
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}
{{ end }}
{{ if $genCloseAndRecv }}
func (x *{{$svrNameCamelCase|untitle}}{{$rpcName}}Client) CloseAndRecv() (*{{$rpcRspType}}, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new({{$rpcRspType}})
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}
{{ end }}
{{ end }}
{{ end }}
{{ end }}

// END ======================================= Client Service Definition ======================================= END
